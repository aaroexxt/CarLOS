<!DOCTYPE HTML>
<html> <!-- manifest="data.appcache" -->
	<head>
		<title>C.OS. MapTest</title>
		<link rel="shortcut icon" href="/favicon.ico" />
		<link rel="stylesheet" type="text/css" media="screen" href="/css/leaflet.css">
		<script src="/js/leaflet.js"></script>
	</head>
	<body>
		<div id="map"></div>
		<canvas id="canv" style="z-index: 1000000 !important; position: absolute;" height="495px" width="495px"></canvas>
		<script>
			//return "https://tile.openstreetmap.org/" + zoom + "/" + x + "/" + coord.y + ".png";
			document.getElementById("map").style.height = window.innerHeight+"px";

			var map = L.map('map', {
				preferCanvas: true,
				center: [37.57,-122.34],
				zoom: 13
			});
			L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar', attribution: '<a href="http://osm.org/copyright">OpenStreetMap</a>'}).addTo(map);
        	

        	L.GridLayer.customGeoRender = L.GridLayer.extend({
			    options: {
			        async: false
			    },

			    initialize: function (options) {
			        L.setOptions(this, options);
			        L.GridLayer.prototype.initialize.call(this, options);
			    },


			    createTile: function (coords) {
			        // create a <canvas> element for drawing
			        var tile = L.DomUtil.create('canvas', 'leaflet-tile');
			        // setup tile width and height according to the options
			        var size = this.getTileSize();
			        tile.width = size.x;
			        tile.height = size.y;
			        // get a canvas context and draw something on it using coords.x, coords.y and coords.z
			        var ctx = tile.getContext('2d');
			        // return the tile so it can be rendered on screen
			        fetch('http://'+window.location.host+'/api/map/tile?x='+coords.x+"&y="+coords.y+"&z="+coords.z, {
						method: 'GET'
					})
					.then(response => response.json())
					.then(response => {
						if (!response.error && !response.wait) { //ok
							var features = response.message ? response.message : [];
							for (var i = 0; i < features.length; i++) {
					            var feature = features[i];
					            this.drawFeature(ctx, feature);
					        }
						} else if (!response.error) {
							console.log("Need to wait for server to be ready...");
						} else {
							console.error(response.message);
						}
					})
			        
			        return tile;
			    },


			    drawFeature: function (ctx, feature) {
			        var typeChanged = type !== feature.type,
			            type = feature.type;
			        ctx.beginPath();
			        if (this.options.style) this.setStyle(ctx, this.options.style);
			        if (type === 2 || type === 3) {
			            for (var j = 0; j < feature.geometry.length; j++) {
			                var ring = feature.geometry[j];
			                for (var k = 0; k < ring.length; k++) {
			                    var p = ring[k];
			                    if (k) ctx.lineTo(p[0] / 16.0, p[1] / 16.0);
			                    else ctx.moveTo(p[0] / 16.0, p[1] / 16.0);
			                }
			            }
			        } else if (type === 1) {
			            for (var j = 0; j < feature.geometry.length; j++) {
			                var p = feature.geometry[j];
			                ctx.arc(p[0] / 16.0, p[1] / 16.0, 2, 0, Math.PI * 2, true);
			            }
			        }
			        if (type === 3) ctx.fill(this.options.style.fillRule || 'evenodd');

			        ctx.stroke();
			    },

			    setStyle: function (ctx, style) {
			        var stroke = style.stroke || true;
			        if (stroke) {
			            ctx.lineWidth = style.weight || 5;
			            var color = this.setOpacity(style.color, style.opacity);
			            ctx.strokeStyle = color;

			        } else {
			            ctx.lineWidth = 0;
			            ctx.strokeStyle = {};
			        }
			        var fill = style.fill || true;
			        if (fill) {
			            ctx.fillStyle = style.fillColor || '#03f';
			            var color = this.setOpacity(style.fillColor, style.fillOpacity);
			            ctx.fillStyle = color;
			        } else {
			            ctx.fillStyle = {};
			        }
			    },

			    setOpacity: function (color, opacity) {
			        if (opacity) {
			            var color = color || '#03f';
			            if (color.iscolorHex()) {
			                var colorRgb = color.colorRgb();
			                return "rgba(" + colorRgb[0] + "," + colorRgb[1] + "," + colorRgb[2] + "," + opacity + ")";
			            } else {
			                return color;
			            }
			        } else {
			            return color;
			        }

			    }
			})

			L.gridLayer.customGeoRenderer = function (options) {
			    return new L.GridLayer.customGeoRender(options);
			};

			String.prototype.iscolorHex = function () {
			    var sColor = this.toLowerCase();
			    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
			    return reg.test(sColor);
			}


			String.prototype.colorRgb = function () {
			    var sColor = this.toLowerCase();
			    if (sColor.length === 4) {
			        var sColorNew = "#";
			        for (var i = 1; i < 4; i += 1) {
			            sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
			        }
			        sColor = sColorNew;
			    }
			    var sColorChange = [];
			    for (var i = 1; i < 7; i += 2) {
			        sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
			    }
			    return sColorChange;
			};  

			var options = {
			    style: {
			        fillColor: '#1EB300',
			        fillOpacity: 0.5,
			        color: '#F2FF00',
			        weight: 2
			    }
			};

			var canvasLayer = L.gridLayer.customGeoRenderer(options).addTo(map);






        	function getVisibleTilesCoords(map) {
		      
		      // get bounds, zoom and tileSize        
		      var bounds = map.getPixelBounds();
		      var zoom = map.getZoom();
		      var tileSize = 256;
		      var tileCoordsContainer = [];


		      // get NorthWest and SouthEast points
		      var nwTilePoint = new L.Point(Math.floor(bounds.min.x / tileSize),
		          Math.floor(bounds.min.y / tileSize));

		      var seTilePoint = new L.Point(Math.floor(bounds.max.x / tileSize),
		          Math.floor(bounds.max.y / tileSize));

		      // get max number of tiles in this zoom level
		      var max = map.options.crs.scale(zoom) / tileSize; 

		      // enumerate visible tiles 
		      for (var x = nwTilePoint.x; x <= seTilePoint.x; x++) 
		      {
		         for (var y = nwTilePoint.y; y <= seTilePoint.y; y++) 
		         {

		            var xTile = Math.abs(x % max);
		            var yTile = Math.abs(y % max);
		            
		            tileCoordsContainer.push({x: xTile, y: yTile});

		            //console.log('tile ' + xTile + ' ' + yTile);
		          }
		      }
		      
		      return tileCoordsContainer;
		      
		    };
    </script>
	</body>
</html>